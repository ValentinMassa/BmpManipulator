//TDA_VECTOR

typedef struct
{
    void* vec;
    int ce;
    int tamMax;
    size_t tamDato;
    float factorIncr;
}TdaVec;

typedef struct
{
    TdaVec* vec;
    void* act;
    void* fin;
    size_t tamDato;
}VecIt;

typedef int(*Cmp)(const void*, const void*);
typedef void(*Mostrar)(void*);


int CrearVectorTDA(TdaVec * vec, size_t tamData);
void DestruirTDA(TdaVec* vec);

int RedimensionarTDA(TdaVec * vec);


int CargarTDAOrdSinDup(TdaVec * vec, void* dato, Cmp cmp1, Cmp cmp2, Accion actualizar, Accion inicializar);
int CargarElementoEnTDAord(TdaVec *vec, void *dato, Cmp cmp, Accion inicializar);
void* BuscarElementoEnTDA(TdaVec *vec, void* dato, Cmp cmp);
void* DevolverPosIdeTDA(TdaVec * vec, int i);
void MostrarTDA(TdaVec * vec, Mostrar muestra);
void CrearvectorIt(TdaVec * vec, VecIt * vecIt);
void* VectorItSiguiene(VecIt *vec);


int RedimensionarTDA(TdaVec * vec)
{
    int NuevaCantMax = vec->tamMax + (int)((float)vec->tamMax * vec->factorIncr);

    void* aux = realloc(vec->vec, NuevaCantMax * vec->tamDato);
    if(!aux)
        return 0;

    vec->vec = aux;
    vec->tamMax = NuevaCantMax;
    return 0;
}



void* BuscarElementoEnTDA(TdaVec *vec, void* dato, Cmp cmp)
{
    VecIt vecIthelp;
    CrearvectorIt(vec, &vecIthelp);
    void* aux;
    while( (aux = VectorItSiguiene(&vecIthelp)) != NULL)
    {
        if(cmp(aux, dato) == 0)
            return aux;
    }
    return NULL;
}

int CargarElementoEnTDAord(TdaVec *vec, void *dato, Cmp cmp, Accion inicializar)
{
    void* aux;
    void* datoFinal = malloc(vec->tamDato);
    if(!datoFinal)
        return 0;

    inicializar(datoFinal, dato);

    if(vec->ce == 0)
    {
        memcpy(vec->vec+(vec->ce * vec->tamDato), datoFinal, vec->tamDato);
        vec->ce ++;
        free(datoFinal);
        return 1;
    }

    int resultado;
    VecIt vecHelp;
    CrearvectorIt(vec, &vecHelp);

    while( (aux = VectorItSiguiene(&vecHelp)) != NULL)
    {
        resultado = cmp(aux, datoFinal);
        if(resultado > 0)
        {
            memmove(aux + vec->tamDato, aux, (vec->vec + (vec->ce * vec->tamDato)) - aux);
            memcpy(aux, datoFinal, vec->tamDato);
            vec->ce ++;
            free(datoFinal);
            return 1;
        }
    }

    memcpy(vec->vec+(vec->ce * vec->tamDato), datoFinal, vec->tamDato);
    vec->ce ++;
    free(datoFinal);
    return 1;
}


void MostrarTDA(TdaVec * vec, Mostrar muestra)
{
    void* aux;
    VecIt vecHelp;
    CrearvectorIt(vec, &vecHelp);

    while( (aux = VectorItSiguiene(&vecHelp)) != NULL)
    {
            muestra(aux);
    }
}



void CrearvectorIt(TdaVec * vec, VecIt * vecIt)
{
    vecIt->vec = vec;
    vecIt->act = vec->vec;
    vecIt->fin = vec->vec + (vec->ce * vec->tamDato);
    vecIt->tamDato = vec->tamDato;
}

void* VectorItSiguiene(VecIt* vec)
{
    if(vec->act == vec->fin)
        return NULL;

    void* aux = vec->act;
    vec->act += vec->tamDato;
    return aux;
}


////////////////////////merge generic


int MergearDosTxt(char* NPosA, char* NposB, char* NposAB)
{
    FILE* FarchA, *FarchB, *FarchAB;

    FarchA = fopen(NPosA, "rt");
    FarchB = fopen(NposB, "rt");
    FarchAB = fopen(NposAB, "wt");
    if(!FarchA || !FarchB || !FarchAB)
    {
        fclose(FarchA);
        fclose(FarchB);
        fclose(FarchAB);
        return 0;
    }

    if(!MergeGenerico(FarchA, FarchB, FarchAB, sizeof(RegistrosPos), TrozarLineaPos, CompararPos, ImprimirPosEnTxr))
       {
            fclose(FarchA);
            fclose(FarchB);
            fclose(FarchAB);
            return 0;
       }
    return 1;
}


int MergeGenerico(FILE* FarchA, FILE* FarchB, FILE*  FarchAB, size_t tam, Trozar TrozarLinea, Cmp comparar, Imprimir ImprimirEnarch)
{
    void* dato1 = malloc(tam);
    if(!dato1)
        return 0;
    void* dato2 = malloc(tam);
    if(!dato2)
        return 0;

    char *punt1,*punt2;
    char buffer1[TAM_BUFFER], buffer2[TAM_BUFFER];
    int resultado;

    punt1 = fgets(buffer1, TAM_BUFFER, FarchA);
    punt2 = fgets(buffer2, TAM_BUFFER, FarchB);
    if(!punt1 || !punt2 )
    {
        free(dato1);
        free(dato2);
        return 0;
    }

    TrozarLinea(buffer1, dato1);
    TrozarLinea(buffer2, dato2);

    while(punt1 && punt2 )
    {
        resultado = comparar(dato1, dato2);

        if(resultado>0) //escribir B
        {
            ImprimirEnarch(FarchAB, dato2);
            punt2 = fgets(buffer2, TAM_BUFFER, FarchB);
            if(punt2)
                TrozarLinea(buffer2, dato2);
        }
        if(resultado<0)// escribir A
        {
            ImprimirEnarch(FarchAB, dato1);
            punt1 = fgets(buffer1, TAM_BUFFER, FarchA);
            if(punt1)
                TrozarLinea(buffer1, dato1);
        }
        if(resultado == 0 ) //primero A desp B
        {
                ImprimirEnarch(FarchAB, dato1);
                ImprimirEnarch(FarchAB, dato2);
                punt1 = fgets(buffer1, TAM_BUFFER, FarchA);
                punt2 = fgets(buffer2, TAM_BUFFER, FarchB);
                if(punt1)
                    TrozarLinea(buffer1, dato1);
                if(punt2)
                    TrozarLinea(buffer2, dato2);
        }
    }
    while(punt1)
    {
        ImprimirEnarch(FarchAB, dato1);
        punt1 = fgets(buffer1, TAM_BUFFER, FarchA);
        if(punt1)
            TrozarLinea(buffer1, dato1);
    }
    while(punt2)
    {
        ImprimirEnarch(FarchAB, dato2);
        punt2 = fgets(buffer2, TAM_BUFFER, FarchB);
        if(punt2)
            TrozarLinea(buffer2, dato2);
    }

    fclose(FarchA);
    fclose(FarchB);
    fclose(FarchAB);
    free(dato1);
    free(dato2);

    return 1;
}



////////////////////////MATRIZ


typedef struct
{
    void** matriz;
    int filas;
    int CeFilas;
    size_t tamElem;
    int columnas;

    int maxFilas;
    float factorIncr;
}
Matriz;

void MostrarMatriz(Matriz *mat, Mostrar muestra);
void InicializarMatriz(Matriz* mat,void** matriz,int filas,int columnas,int CeFilas,size_t tamElem);
int CrearMatrizDinamica(Matriz* mat, size_t Tamelem, int Filas, int columnas);
int CargarValorEnFilaNColJ(Matriz * mat,int filaN, int ColJ, void* elem);
int RedimencionarMatriz(Matriz* mat);
int ObtenermaxCol(Matriz* mat);
int AumentarFila(Matriz* mat);
void DestruirMatriz(Matriz * mat);
void* ObtenerDatoFilaNcolumnaJMatriz(Matriz* mat, int fila, int col);
void PermutarDatos(void* dato1, void* dato2, size_t tam);


void MostrarMatriz(Matriz *mat, Mostrar muestra)
{
    puts("matriz: ");

    for(void** fila = mat->matriz; fila < mat->matriz + mat->CeFilas; fila++)
    {//vamos a harcodear 7 columnas, asi se muestra bien
    //for(void* columna = *fila; columna < (*fila) + (mat->columnas * mat->tamElem); columna+= mat->tamElem)
    //donde esta el 7 deberia ir esto ^
    for(void* columna = *fila; columna < (*fila) + (7 * mat->tamElem); columna+= mat->tamElem)
        {
            muestra(columna);
            printf("|");
        }
        printf("\n");
    }
}

void InicializarMatriz(Matriz* mat,
                        void** matriz,
                        int filas, int columnas,
                        int CeFilas,
                        size_t tamElem)
    {

        mat->matriz = matriz;
        mat->CeFilas = CeFilas;
        mat->filas = filas;
        mat->tamElem = tamElem;
        mat->columnas = columnas;
    }

int CrearMatrizDinamica(Matriz* mat, size_t Tamelem, int Filas, int columnas)
{
    void** auxiliar = (void**)malloc(sizeof(void*) * Filas);


    if(!auxiliar)
        return ERR;

    for(void** inicio = auxiliar; inicio < auxiliar + Filas; inicio ++)
    {
        *inicio = calloc(columnas, Tamelem);
        if(!(*inicio))
        {
            for(void** fin = inicio - 1; fin >= auxiliar; fin --)
                free(*fin);
            free(auxiliar);
            InicializarMatriz(mat, NULL, 0, 0,0,0);
            return ERR;
        }

    }
    InicializarMatriz(mat, auxiliar, Filas,columnas,0, Tamelem);
    return OK;
}


int CargarValorEnFilaNColJ(Matriz * mat,int filaN, int ColJ, void* elem)
{

    if(filaN<0 || ColJ < 0)
        return ERR;

    if(filaN >= mat->CeFilas)
        return ERR;

    if(ColJ >= mat->columnas)
        return ERR;

    memcpy( *(mat->matriz + filaN) + (ColJ * mat->tamElem), elem, mat->tamElem);


    return OK;
}


int RedimencionarMatriz(Matriz* mat)
{
    int Nueva_Fila =  mat->filas + (int)((float)mat->filas * (mat->factorIncr + 1));
    if(Nueva_Fila > mat->maxFilas)
        Nueva_Fila = mat->maxFilas;
    if(Nueva_Fila == mat->CeFilas)
    {
        puts("max alcanzado");
        return ERR;
    }
    void** NuevaDir = (void**)realloc(mat->matriz, Nueva_Fila*sizeof(void*));
    if(!NuevaDir)
        return ERR;

    void** inicio;
    void** fin = NuevaDir + Nueva_Fila;

    for(inicio = NuevaDir + mat->CeFilas; inicio < fin; inicio++)
    {
        *inicio = calloc(mat->columnas, mat->tamElem);
        if(!(*inicio))
        {
            for(void** liberar = inicio -1; liberar >= mat->matriz; liberar -- )
                free(*liberar),
            free(mat->matriz);
            InicializarMatriz(mat, NULL, 0, 0,0,0);
            return ERR;
        }
    }
    mat->matriz = NuevaDir;
    mat->filas = Nueva_Fila;
    return OK;

}

int AumentarFila(Matriz* mat)
{
    if(mat->CeFilas == mat->filas)
    {
        if(!RedimencionarMatriz(mat))
            return ERR;
    }
    mat->CeFilas ++;
    return OK;
}

void DestruirMatriz(Matriz * mat)
{
    void** inicio;
    void** fin = mat->matriz + mat->filas;
    for(inicio = mat->matriz ; inicio< fin; inicio ++)
        free(*inicio);
    free(mat->matriz);
}

void* ObtenerDatoFilaNcolumnaJMatriz(Matriz* mat, int fila, int col)
{
    if(fila < 0 || col< 0)
        return NULL;
    if(fila >= mat->CeFilas || col >= mat->columnas)
        return ERR;

    return ( *(mat->matriz + fila) + (col * mat->tamElem));
}


int ObtenermaxCol(Matriz* mat)
{
    return mat->columnas;
}


///TDA_ VERSION 2

typedef struct
{
    void* vec;
    int ce;
    int MaxTam;
    float FactorInc;
    size_t Tamdata;
}
TDAvec;

typedef struct
{
    TDAvec * TdaVec;
    void* act;
    void* fin;
    size_t tamData;
}
VectorIt;

int CrearTDA(TDAvec * vec, size_t tam);
int CargarTDAdesdeTxt(char*, TDAvec*, Trozar);
void* UltimaPosVaciaEnVecTDA(TDAvec* vec);
int CargarElementoEnTDA(TDAvec* vec, void* aux);
void MostrarTDA(TDAvec * vec, Mostrar muestra);
int RedimensionarTDA(TDAvec * vec);
void DestruirTDA(TDAvec *vec);


void InicializarVecIt(TDAvec* vec, VectorIt* vecIt);
void* ProximoElementoVecIt(VectorIt* vecIt);
void InicializarVecItSentidoContrario(TDAvec* vec, VectorIt* vecIt);
void* ProximoElementoVecSentidoContrarioIt(VectorIt* vecIt);



int CrearTDA(TDAvec * vec, size_t tam)
{
    void* aux = malloc(tamMaxVec * tam);
    if(!aux)
        return ERR;

    vec->vec = aux;
    vec->ce= 0;
    vec->FactorInc = FactorIncremento;
    vec->MaxTam = tamMaxVec;
    vec->Tamdata = tam;
    return OK;
}

int RedimensionarTDA(TDAvec * vec)
{
    int NuevaCantReg = vec->MaxTam + (int)( (float)vec->MaxTam * vec->FactorInc);

    void* aux = realloc(vec->vec, vec->Tamdata * NuevaCantReg);

    if(!aux)
        return ERR;

    vec->MaxTam = NuevaCantReg;
    vec->vec = aux;
    return OK;
}

int CargarTDAdesdeTxt(char* Nperm, TDAvec* vec, Trozar trozarLinea)
{
    char buffer[Tambuffer];

    FILE* FarchPermIdx = fopen(Nperm, "rt");
    if(!FarchPermIdx)
        return ERR;

    void* aux = malloc(vec->Tamdata);

    while( fgets(buffer, Tambuffer, FarchPermIdx)!= NULL )
    {
        if(!trozarLinea(buffer,  aux))
            return ERR;

        if(!CargarElementoEnTDA(vec, aux))
            return ERR;
    }

    free(aux);
    fclose(FarchPermIdx);
    return OK;
}

int CargarElementoEnTDA(TDAvec* vec, void* aux)
{
    void* pos = UltimaPosVaciaEnVecTDA(vec);
    if(!aux)
        return ERR;
    memcpy(pos, aux, vec->Tamdata);

    vec->ce ++;
    return OK;
}

void* UltimaPosVaciaEnVecTDA(TDAvec* vec)
{
    if(vec->ce == vec->MaxTam)
        {
            if(!RedimensionarTDA(vec))
                return NULL;
        }
    return (vec->vec + (vec->ce*vec->Tamdata));
}


void MostrarTDA(TDAvec * vec, Mostrar muestra)
{
    VectorIt vecIt;
    void* aux;

    InicializarVecIt(vec, &vecIt);
    puts("Vector TDA");
    while( (aux = ProximoElementoVecIt(&vecIt)) != NULL )
    {
        muestra(aux);
    }
}

void DestruirTDA(TDAvec *vec)
 {
     free(vec->vec);
 }



//////tdaFECHA


#ifndef FECHAS_H_
#define FECHAS_H_

#include <stdio.h>

typedef struct {
    int di, me, an;
} tFecha;

#define AN_MIN 1
#define AN_MAX 5000
#define esBisiesto(X) (((X) % 4 == 0 && (X) % 100 != 0) || (X) % 400 == 0)

int ingresarFechaDMA(tFecha *fec, const char *mensajeOpcional);
void mostrarFechaDMA(const tFecha *fec);
int esFechaValida(const tFecha *fec);
int ingresarFechaValidaDMA(tFecha *fec, const char *mensajeOpcional);
int compararFecha(const tFecha *fec1, const tFecha *fec2);
int aJuliano(const tFecha *fec);
int nroDeDiaDeLaSemana(const tFecha *fec);
long diasEntreFechas(const tFecha *fecDesde, const tFecha *fecHasta);
tFecha calcularEdad(const tFecha *fecDesde, const tFecha *fecHasta);

#endif


#include "fechas.h"

int ingresarFechaDMA(tFecha *fec, const char *mensajeOpcional) {
    if (mensajeOpcional) printf("%s", mensajeOpcional);
    else printf("Fecha (dd/mm/aaaa - 0=No Ingresa): ");
    scanf("%d/%d/%d", &fec->di, &fec->me, &fec->an);
    return fec->di && fec->me && fec->an;
}

void mostrarFechaDMA(const tFecha *fec) {
    printf("%02d/%02d/%04d", fec->di, fec->me, fec->an);
}

int esFechaValida(const tFecha *fec) {
    static const char dias[][12] = {
        {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
        {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}};
    return fec->me > 0 && fec->me <= 12 &&
           fec->an >= AN_MIN && fec->an <= AN_MAX &&
           fec->di > 0 && fec->di <= dias[esBisiesto(fec->an)][fec->me - 1];
}

int ingresarFechaValidaDMA(tFecha *fec, const char *mensajeOpcional) {
    do {
        if (!ingresarFechaDMA(fec, mensajeOpcional)) return 0;
    } while (!esFechaValida(fec));
    return 1;
}

int compararFecha(const tFecha *fec1, const tFecha *fec2) {
    int cmp = fec1->an - fec2->an;
    if (cmp) return cmp;
    cmp = fec1->me - fec2->me;
    if (cmp) return cmp;
    return fec1->di - fec2->di;
}

int aJuliano(const tFecha *fec) {
    int dias[][12] = {
        {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334},
        {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335}};
    return dias[esBisiesto(fec->an)][fec->me - 1] + fec->di;
}

int nroDeDiaDeLaSemana(const tFecha *fec) {
    int distBase = fec->an % 400;
    return (6 + distBase + distBase / 4 - distBase / 100 + (distBase != 0) + aJuliano(fec)) % 7;
}

long diasEntreFechas(const tFecha *fecDesde, const tFecha *fecHasta) {
    int anBase = fecDesde->an <= fecHasta->an ? fecDesde->an : fecHasta->an;
    int distDesde = fecDesde->an - anBase, distHasta = fecHasta->an - anBase;
    long diasDesde = distDesde * 365L + distDesde / 4 - distDesde / 100 + distDesde / 400 + aJuliano(fecDesde);
    long diasHasta = distHasta * 365L + distHasta / 4 - distHasta / 100 + distHasta / 400 + aJuliano(fecHasta);
    return diasHasta - diasDesde;
}

tFecha calcularEdad(const tFecha *fecDesde, const tFecha *fecHasta) {
    static const char dias[][13] = {
        {0, 31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30},
        {0, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30}};
    tFecha edad = *fecHasta;
    if ((edad.di -= fecDesde->di) < 0) {
        edad.di += dias[esBisiesto(edad.an)][edad.me];
        edad.me--;
    }
    if ((edad.me -= fecDesde->me) < 0) {
        edad.me += 12;
        edad.an--;
    }
    edad.an -= fecDesde->an;
    return edad;
}

